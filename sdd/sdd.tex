\documentclass{report}
\usepackage{graphicx}
\usepackage{float}
\usepackage{fullpage}
\usepackage{array}
%\usepackage{pdflscape}
\usepackage{lscape}
%\usepackage[parfill]{parskip}

\setlength{\extrarowheight}{4pt}

\graphicspath{{./images/}}

\floatstyle{boxed}
\restylefloat{figure}

\begin{document}
\input{title.tex}
\tableofcontents
\listoffigures
\listoftables
\chapter{Introduction} % 10% Zack
\label{ch:introduction}

\section{Executive Summary}

\section{Purpose}

\section{Scope}

\section{Assumptions}

\section{Changes to Requirements}

\section{Design Goals}

\section{Prioritization of Functionality}

\section{Terminology and Definitions}
\begin{description}
\item[RAID]
\item[Parity disk]
\item[rsync]
\item[SHA1]
\item[SQL]
\end{description}

%\section{References}

\chapter{Architecture} % 20% - Casey
\label{ch:architecture}

% Subsystems
% - Hardware interfacing (drivers for ZigBee)
% - Communications protocol (RPC over TCP/IP)
% - Event handling (event queue)
% - External interface (JSON RPC over HTTP)
% - Sensor OS

The architecture of GARTH is both a layered architecture as well as a
client/server architecture. All communications related subsystems, such as
hardware interfacing, communications protocols, and event handling are
layered. Subsystems such as external interfacing, inter-process communications,
and sensor communication use a client/server model.

Layering the communications subsystems will allow for more abstraction and
easier seperation, leading to an increased ease of implementation for these
systems. Seperating the subsystems in layers allows for parallel work to occur
on these layers, as they can individually be developed and tested before being
integrated together. An approach similar to the OSI model was chosen, with the
physical layer at the bottom. The communication subsystem layer hierarchy is
shown in Figure~\ref{fig:communication_layers}.

\floatstyle{plain}
\restylefloat{figure}
\begin{figure}[hp]
    \centering
        \caption{Communication Layer Heirarchy}
        \scriptsize
        \setlength{\unitlength}{2.0em}
        \includegraphics{communication_layers1.mps}
        \normalsize
    \label{fig:communication_layers}
\end{figure}
\floatstyle{boxed}
\restylefloat{figure}


Using a client server model allows for work to be 

\section{Overview}

\section{Subsystem Decomposition}

\chapter{System Design} % 10% Zack
\label{ch:system-design}

\section{Hardware/Software Mapping}

\section{Data Resource Management}
%TODO mentioned proprietary software that should be fleshed out in this SDD

The two main components to GARTH's data resource management are the local
storage hardware and the remote server. The local storage component is
contained within the home and consists of a Linux server that will be stored in
a secure location. The Linux server is a desktop computer with four 2TB hard
drives arranged in a modified RAID array with a parity disk for redundancy. In
this case, if a hard drive should fail the system will continue to run as
expected until a replacement hard drive gets installed. The server will use
proprietary software  to create TXT files that log system events as well as
store video that is captured by the cameras situated within and outside the
home.

The remote server is back-up storage that is located offsite at GARTH
headquarters. It is merely a remote backup of system logs and important video
data that should be saved for future reference. This includes any log-files or
video that was recorded by the system during a critical security violation.
This synchronization will be accomplished by using \textbf{rsync} network
protocol installed on both the local and remote server. The data that is backed
up remotely will be stored in a SQL database such that storing and querying
important data can be accomplished easily.

\section{Access Control and Security}

All access control data will be stored in the local storage database and will be
organized in an access array. The access control array will store user
information, IDs, passwords and priviliges.  This data will be encrypted using
the SHA1 hash algorithm to ensure that this data will be irrelevent to anyone
who accesses it unrightfully. This array can be accessed at any time by the
system to allow necessary access to a user. 

\begin{table}[h]
    \caption{Example of a GARTH access array}
    \label{access_array}
    \centering
    \begin{tabular}{| l | l | l | l | l | l |}
    \hline
    \textbf{Entry ID \#}&\textbf{User ID String}&\textbf{Username}&\textbf{Password}&\textbf{NFC ID}&\textbf{Privileges} \\ \hline
    1&Daryl Simpson&d\_simpson22&\$taRfi\$h&darylBB&Administrator \\ \hline
    2&Megan Simpson&msimpson&Portia&meganBold&Administrator \\ \hline
    3&Charlotte Simpson&charlotte11&Barbie11&charPod&Arm/Disarm \\
    \hline
    \end{tabular}
\end{table}

The array contains relevant information for each person who will be using the
system. The array contains a username and password for each user, in case
they need to log-in through the console's interface to change settings. Certain
settings will only be able to get changed by users with administator access.
The NFC ID field stores the device name of the NFC device the user chose to
arm or disarm the security system.

\section{Global Software Control}

\section{Boundary Conditions}

\chapter{Interfaces} % 10% - cccbanne
\label{ch:interfaces}



\section{External System Interfaces}

\floatstyle{plain}
\restylefloat{figure}
\begin{figure}[hp]
    \centering
        \caption{External System Interfaces}
        \scriptsize
        \setlength{\unitlength}{2.0em}
        \includegraphics{external_interfaces1.mps}
        \normalsize
    \label{fig:external_interfaces}
\end{figure}
\floatstyle{boxed}
\restylefloat{figure}

\section{Internal Subsystem Interfaces}



\chapter{Object Design} % 30%
\label{ch:object-design}

\section{Design Patterns}

\section{Algorithms}

\section{Packages}

\section{Object and Interface Design}

\section{Dynamic Design Model}

\chapter{Design Evaluation} % 10% Zack
\label{ch:design-evaluation}

\section{Design Trade-offs}

\section{Re-use}

\section{Optimizations}

\section{Extensibility}

\chapter{Operating Environment} % 10% 
% BEN IS GOT THIS.
\label{ch:operating-environment}

\section{Development Platform}
%In general terms, describe the anticipated platform on which this system will
%be developed, including the implementation language, major libraries and
%network protocols utilized, and special language or OS or middleware features
%used, such as remote procedure calls, a built-in event handling model, user
%interface library, etc.

\section{Runtime Platform}
%Describe the platform on which this system will be deployed and run, including
%the operating system, any required middleware, and hardware. You may describe
%the prototype in particular, if the final system is still unclear.

% Controllers:
%   OS = Linux
%   Hardware = Server blade with redundencies
%  
% Sensors:  
%   OS = tinyOS
%   Hardware = Microcontroller with Zigbee
%
% Middleware:
%   Communication between sensors and controllers (via the server) with a
%   xigbee base station connected to the server.

The platform is divided into two major types of components, controllers and
sensors. Both types have different requirements for operating systems and
hardware. Middleware is required to interface between the two subsystems as well. 

The controllers will all operate on a single server as seperate processes. The
server will be a Linux based server orientated distribution such as CentOS or
Debian. The server will be housed locally within the house. The hardware needs
to be powerful, yet energy efficient and compact. No dependance on exact
hardware is required. Some recommended specifications are outlined in
Table~\ref{server_hardware}.

Each sensor will have its own independent hardware and operating system due to
the independent nature of these devices. Each will have an Atmel AVR ATMega
microcontroller for reading sensor data and communicating through the Zigbee.
The tinyOS operating system can be used to quicken development time and the
protocols for communication with the Zigbee. The tinyOS will also simplify
setting up the mesh network as several modules are provided for this.

Some middleware is required to interface the sensors and the controllers
through a Zigbee and microcontroller connected via USB to the server. A simple
hardware interface is required to allow for two-way communication between the
controllers and the sensors.

\begin{table}[h]
    \caption{Recommended Server Hardware}
    \label{server_hardware}
    \centering
    \begin{tabular}{| c | p{5cm} |}
    \hline
    Processor & AMD Athlon II X3 445 \\ \hline
    Motherboard & ASUS M5A78L-M LX PLUS AMD 760G Motherboard - Micro ATX,
    AMD 760G Chipset, 1866MHz DD3 (O.C.), SATA 3.0 Gb/s, RAID, Gigabit LAN \\
    \hline
    Case &  XION XON-810P-Red Micro ATX/ITX with 450W PSU \\ \hline
    Memory & Corsair Value Select PC10600 RAM - 2GB, DDR3, 1333Mhz \\ \hline
    Hard Drive & Western Digital Caviar Green - 1 TB \\
    \hline
    \end{tabular}
\end{table}


\section{Process Model}
%Describe whether the system is multi-threaded, runs on concurrent processes, or
%is distributed. Identify the major concurrent activities and objects (you may
%refer to the object or dynamic model), and how they will be manifested on the
%target system.

The system as a whole is distributed system, with subsystems consisting of
concurrent processes or single threaded microcontrollers. The sensor network is
one distributed subsystem that consists of many single process
microcontrollers. The controllers located on the server are concurrent
processes.

% TODO :: Refer to object/dynamic model and shit.

\section{Synchronization}
%Describe the method of coordination and synchronization between software
%tasks, such as semaphores or message queues.
Coordination and synchronization between software is done through message
queues. More specifically, the event objects are passed between interfaces and
are handled as the messages in the event queues. These event queues will
have different priority levels as some events are more critical then others in
terms of time sensitivity. 

\section{Fault Handling}
%Explain how errors will be handled. For instance, describe the use of
%exception handling in the system. Discuss how the system may recover from
%software or hardware failure.
Errors will be handled on a case by case basis as some errors will not affect
day to day operation of the system. Minor errors such as a temperature misread
or missing data from one of the passively read sensors can be ignored as long
as it is a transient event. Major errors such as a missing sensor or low
battery levels on a sensor will need to be handled. Critical errors such as a
hardware failure in the base station or server will require special care.

Minor errors can be ignored for the most part. These represent one time sensor
misreads, missing data, and other faults that do not affect any long term
operation of the system. These minor faults still need to be accounted for as
multiple occurances of this type will imply an issue with the sensor or
communication interface. When a minor error is detected, the error needs to be
logged but no further action is required.

Major errors will require system action and possibly user action to correct.
Major faults include missing sensors, low battery levels, and other issues that
will affect the short-term and long-term operation of the system. These faults
need to be accounted for and handled appropriately. In some cases, the user
will need to alerted with information on how to take the appropriate actions.
For example, if a sensor has low battery levels then the user will need to
replace or recharge the battery to ensure proper and continuous operation.

The final error criticality level is critical faults. Complete hardware or
software failures of the server can be considered critical faults. If the fault
is easily recoverable, such as a brown out causing a power flicker at the
house, then the components effected need to restart as quickly as possible to
ensure proper and consistent operation. For other faults such as hardware
failure in the base station or the server, then the user will need to take
appropriate action to fix the malfunctioning hardware.

\end{document}
